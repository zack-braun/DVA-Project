{
  "_args": [
    [
      "react-docgen@3.0.0-beta12",
      "/home/joseph/Desktop/DVA-Project/Node/node_modules/react-styleguidist"
    ]
  ],
  "_from": "react-docgen@3.0.0-beta12",
  "_hasShrinkwrap": false,
  "_id": "react-docgen@3.0.0-beta12",
  "_inCache": true,
  "_installable": true,
  "_location": "/react-docgen",
  "_nodeVersion": "8.9.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-docgen_3.0.0-beta12_1523508194103_0.7092269772270279"
  },
  "_npmUser": {
    "email": "felix.kling@gmx.net",
    "name": "fkling"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {
    "esprima": "4.0.1",
    "private": "0.1.8",
    "source-map": "0.6.1"
  },
  "_requested": {
    "name": "react-docgen",
    "raw": "react-docgen@3.0.0-beta12",
    "rawSpec": "3.0.0-beta12",
    "scope": null,
    "spec": "3.0.0-beta12",
    "type": "version"
  },
  "_requiredBy": [
    "/react-styleguidist"
  ],
  "_resolved": "https://registry.npmjs.org/react-docgen/-/react-docgen-3.0.0-beta12.tgz",
  "_shasum": "1285839296d6b616715b75c9d57f08d17c500be9",
  "_shrinkwrap": null,
  "_spec": "react-docgen@3.0.0-beta12",
  "_where": "/home/joseph/Desktop/DVA-Project/Node/node_modules/react-styleguidist",
  "author": {
    "name": "Felix Kling"
  },
  "bin": {
    "react-docgen": "bin/react-docgen.js"
  },
  "bugs": {
    "url": "https://github.com/reactjs/react-docgen/issues"
  },
  "dependencies": {
    "async": "^2.1.4",
    "babel-runtime": "^6.9.2",
    "babylon": "7.0.0-beta.40",
    "commander": "^2.9.0",
    "doctrine": "^2.0.0",
    "node-dir": "^0.1.10",
    "recast": "^0.13.0"
  },
  "description": "A CLI and toolkit to extract information from React components for documentation generation.",
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-core": "^6.26.0",
    "babel-eslint": "^8.0.1",
    "babel-jest": "^22.2.2",
    "babel-plugin-transform-object-rest-spread": "^6.26.0",
    "babel-plugin-transform-runtime": "^6.23.0",
    "babel-preset-env": "^1.6.1",
    "babel-preset-flow": "^6.23.0",
    "cross-spawn": "^6.0.4",
    "eslint": "^4.3.0",
    "flow-bin": "^0.66.0",
    "jest": "^22.3.0",
    "jest-diff": "^22.1.0",
    "jest-matcher-utils": "^22.2.0",
    "rimraf": "^2.3.2",
    "temp": "^0.8.1"
  },
  "directories": {},
  "dist": {
    "fileCount": 67,
    "integrity": "sha512-8DE3R6mPJSpBS2k6nw4hyZ/E+k60tE/AzLe/ncfyf3AQnd1pojo8cCn2ziXU33Vfny5u7G0pCrL01h9rcX6MTw==",
    "shasum": "1285839296d6b616715b75c9d57f08d17c500be9",
    "tarball": "https://registry.npmjs.org/react-docgen/-/react-docgen-3.0.0-beta12.tgz",
    "unpackedSize": 194561
  },
  "files": [
    "PATENTS",
    "bin",
    "dist"
  ],
  "gitHead": "bda19f53db164c20a0226affe71b348c9c52c456",
  "homepage": "https://github.com/reactjs/react-docgen#readme",
  "jest": {
    "roots": [
      "bin",
      "src"
    ],
    "setupTestFrameworkScriptFile": "<rootDir>/tests/setupTestFramework.js",
    "testRegex": "/__tests__/.*-test\\.js$"
  },
  "keywords": [
    "documentation-generation",
    "react"
  ],
  "license": "BSD-3-Clause",
  "main": "dist/main.js",
  "maintainers": [
    {
      "name": "danez",
      "email": "daniel@tschinder.de"
    },
    {
      "name": "fb",
      "email": "opensource+npm@fb.com"
    },
    {
      "name": "fkling",
      "email": "felix.kling@gmx.net"
    }
  ],
  "name": "react-docgen",
  "optionalDependencies": {},
  "readme": "# react-docgen [![Build Status](https://travis-ci.org/reactjs/react-docgen.svg?branch=master)](https://travis-ci.org/reactjs/react-docgen)\n\n`react-docgen` is a CLI and toolbox to help extracting information from [React][] components, and generate documentation from it.\n\nIt uses [recast][] and [babylon][] to parse the source into an AST and provides methods to process this AST to extract the desired information. The output / return value is a JSON blob / JavaScript object.\n\nIt provides a default implementation for React components defined via\n`React.createClass`, [ES2015 class definitions][classes] or functions\n(stateless components). These component definitions must follow certain\nguidelines in order to be analyzable (see below for more info).\n\n## Install\n\nInstall the module directly from npm:\n\n```\nnpm install -g react-docgen\n```\n\n## CLI\n\nInstalling the module adds a `react-docgen` executable which allows you to convert\na single file, multiple files or an input stream. We are trying to make the\nexecutable as versatile as possible so that it can be integrated into many\nworkflows.\n\n```\nUsage: react-docgen [path]... [options]\n\npath     A component file or directory. If no path is provided it reads from stdin.\n\nOptions:\n   -o FILE, --out FILE   store extracted information in FILE\n   --pretty              pretty print JSON\n   -x, --extension       File extensions to consider. Repeat to define multiple extensions. Default:  [js,jsx]\n   -e, --exclude         Filename pattern to exclude. Default:  []\n   -i, --ignore          Folders to ignore. Default:  [node_modules,__tests__,__mocks__]\n   --resolver RESOLVER   Resolver name (findAllComponentDefinitions, findExportedComponentDefinition) or\n      path to a module that exports a resolver.  [findExportedComponentDefinition]\n\nExtract meta information from React components.\nIf a directory is passed, it is recursively traversed.\n```\n\nBy default, `react-docgen` will look for the exported component created through\n`React.createClass`, a class definition or a function (stateless component) in\neach file. You can change that behavior with the `--resolver` option, which\neither expects the name of a built-in resolver or a path to JavaScript module\nexporting a resolver function. Have a look below for [more information about\nresolvers](#resolver).\n\nHave a look at `example/` for an example of how to use the result to generate a\nmarkdown version of the documentation.\n\n## API\n\nThe tool can be used programmatically to extract component information and customize the extraction process:\n\n```js\nvar reactDocs = require('react-docgen');\nvar componentInfo = reactDocs.parse(src);\n```\n\nAs with the CLI, this will look for the exported component created through `React.createClass` or a class definition in the provided source. The whole process of analyzing the source code is separated into two parts:\n\n- Locating/finding the nodes in the AST which define the component\n- Extracting information from those nodes\n\n`parse` accepts more arguments with which this behavior can be customized.\n\n### parse(source \\[, resolver \\[, handlers\\]\\])\n\n| Parameter |  Type | Description |\n| -------------- | ------ | --------------- |\n| source       | string | The source text |\n| resolver     | function | A function of the form `(ast: ASTNode, recast: Object) => (NodePath|Array<NodePath>)`. Given an AST and a reference to recast, it returns an (array of) NodePath which represents the component definition. |\n| handlers    | Array\\<function\\> | An array of functions of the form `(documentation: Documentation, definition: NodePath) => void`. Each function is called with a `Documentation` object and a reference to the component definition as returned by `resolver`. Handlers extract relevant information from the definition and augment `documentation`. |\n\n#### resolver\n\nThe resolver's task is to extract those parts from the source code which the handlers can analyze. For example, the `findExportedComponentDefinition` resolver inspects the AST to find\n\n```js\nvar Component = React.createClass(<def>);\nmodule.exports = Component;\n\n// or\n\nclass Component extends React.Component {\n  // ...\n}\nmodule.exports = Component;\n```\n\nand returns the ObjectExpression to which `<def>` resolves to, or the class declaration itself.\n\n`findAllComponentDefinitions` works similarly, but finds *all* `React.createClass` calls and class definitions, not only the one that is exported.\n\nThis makes it easy, together with the utility methods created to analyze the AST, to introduce new or custom resolver methods. For example, a resolver could look for plain ObjectExpressions with a `render` method.\n\n#### handlers\n\nHandlers do the actual work and extract the desired information from the result the resolver returned. Like the resolver, they try to delegate as much work as possible to the reusable utility functions.\n\nFor example, while the `propTypesHandler` expects the prop types definition to be an ObjectExpression and be available as `propTypes` in the component definition, most of the work is actually performed by the `getPropType` utility function.\n\n## Guidelines for default resolvers and handlers\n\n- Modules have to export a single component, and only that component is analyzed.\n- When using `React.createClass`, the component definition (the value passed to it) must resolve to an object literal.\n- When using classes, the class must either `extend React.Component` *or* define a `render()` method.\n- `propTypes` must be an object literal or resolve to an object literal in the same file.\n- The `return` statement in `getDefaultProps` must contain an object literal.\n\n## PropTypes\n\n### Example\n\nFor the following component\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * General component description.\n */\nclass MyComponent extends Component {\n  render: function() {\n    // ...\n  }\n}\n\nMyComponent.propTypes = {\n  /**\n   * Description of prop \"foo\".\n   */\n  foo: PropTypes.number,\n  /**\n   * Description of prop \"bar\" (a custom validation function).\n   */\n  bar: function(props, propName, componentName) {\n    // ...\n  },\n  baz: PropTypes.oneOfType([\n    PropTypes.number,\n    PropTypes.string\n  ]),\n};\n\nMyComponent.defaultProps = {\n  foo: 42,\n  bar: 21\n};\n\nexport default Component;\n```\n\nwe are getting this output:\n\n```json\n{\n  \"props\": {\n    \"foo\": {\n      \"type\": {\n        \"name\": \"number\"\n      },\n      \"required\": false,\n      \"description\": \"Description of prop \\\"foo\\\".\",\n      \"defaultValue\": {\n        \"value\": \"42\",\n        \"computed\": false\n      }\n    },\n    \"bar\": {\n      \"type\": {\n        \"name\": \"custom\"\n      },\n      \"required\": false,\n      \"description\": \"Description of prop \\\"bar\\\" (a custom validation function).\",\n      \"defaultValue\": {\n        \"value\": \"21\",\n        \"computed\": false\n      }\n    },\n    \"baz\": {\n      \"type\": {\n        \"name\": \"union\",\n        \"value\": [\n          {\n            \"name\": \"number\"\n          },\n          {\n            \"name\": \"string\"\n          }\n        ]\n      },\n      \"required\": false,\n      \"description\": \"\"\n    }\n  },\n  \"description\": \"General component description.\"\n}\n```\n\n## Flow Type support\n\nIf you are using [flow][flow] then react-docgen can also extract the flow type annotations. As flow has a way more advanced and fine granular type system, the returned types from react-docgen are different in comparison when using `React.PropTypes`.\n\n> **Note**: react-docgen will not be able to grab the type definition if the type is imported or declared in a different file.\n\n### Example\n\nFor the following component\n\n```js\nimport React, { Component } from 'react';\n\ntype Props = {\n  /** Description of prop \"foo\". */\n  primitive: number,\n  /** Description of prop \"bar\". */\n  literalsAndUnion: 'string' | 'otherstring' | number,\n  arr: Array<any>,\n  func?: (value: string) => void,\n  noParameterName?: string => void,\n  obj?: { subvalue: ?boolean },\n};\n\n/**\n * General component description.\n */\nexport default class MyComponent extends Component<void, Props, void> {\n\n  props: Props;\n\n  render(): ?ReactElement {\n    // ...\n  }\n}\n```\n\nwe are getting this output:\n\n```json\n{\n  \"description\":\"General component description.\",\n  \"props\":{\n    \"primitive\":{\n      \"flowType\":{ \"name\":\"number\" },\n      \"required\":true,\n      \"description\":\"Description of prop \\\"foo\\\".\"\n    },\n    \"literalsAndUnion\":{\n      \"flowType\":{\n        \"name\":\"union\",\n        \"raw\":\"'string' | 'otherstring' | number\",\n        \"elements\":[\n          { \"name\":\"literal\", \"value\":\"'string'\" },\n          { \"name\":\"literal\", \"value\":\"'otherstring'\" },\n          { \"name\":\"number\" }\n        ]\n      },\n      \"required\":true,\n      \"description\":\"Description of prop \\\"bar\\\".\"\n    },\n    \"arr\":{\n      \"flowType\":{\n        \"name\":\"Array\",\n        \"elements\":[\n          { \"name\":\"any\" }\n        ],\n        \"raw\":\"Array<any>\"\n      },\n      \"required\":true\n    },\n    \"func\":{\n      \"flowType\":{\n        \"name\":\"signature\",\n        \"type\":\"function\",\n        \"raw\":\"(value: string) => void\",\n        \"signature\":{\n          \"arguments\":[\n            { \"name\":\"value\", \"type\":{ \"name\":\"string\" } }\n          ],\n          \"return\":{ \"name\":\"void\" }\n        }\n      },\n      \"required\":false\n    },\n    \"noParameterName\":{\n      \"flowType\":{\n        \"name\":\"signature\",\n        \"type\":\"function\",\n        \"raw\":\"string => void\",\n        \"signature\":{\n          \"arguments\":[\n            { \"name\":\"\", \"type\":{ \"name\":\"string\" } }\n          ],\n          \"return\":{ \"name\":\"void\" }\n        }\n      },\n      \"required\":false\n    },\n    \"obj\":{\n      \"flowType\":{\n        \"name\":\"signature\",\n        \"type\":\"object\",\n        \"raw\":\"{ subvalue: ?boolean }\",\n        \"signature\":{\n          \"properties\":[\n            {\n              \"key\":\"subvalue\",\n              \"value\":{\n                \"name\":\"boolean\",\n                \"nullable\":true,\n                \"required\":true\n              }\n            }\n          ]\n        }\n      },\n      \"required\":false\n    }\n  }\n}\n```\n\n### Types\n\nHere is a list of all the available types and its result structure.\n\nName  | Examples | Result\n------------- | ------------- | -------------\nSimple  | ```let x: string;```<br />```let x: number;```<br />```let x: boolean;```<br />```let x: any;```<br />```let x: void;```<br />```let x: Object;```<br />```let x: String;```<br />```let x: MyClass;``` | ```{ \"name\": \"<type>\" }```\nLiterals  | ```let x: 'foo';```<br />```let x: 1;```<br />```let x: true;``` | ```{ \"name\": \"literal\", \"value\": \"<rawvalue>\" }```\nTyped Classes  | ```let x: Array<foo>;```<br />```let x: Class<foo>;```<br />```let x: MyClass<bar>;``` | ```{ \"name\": \"<type>\", \"elements\": [{ <element-type> }, ...] }```\nObject Signature  | ```let x: { foo: string, bar?: mixed };```<br />```let x: { [key: string]: string, foo: number };``` | ```{ \"name\": \"signature\", \"type\": \"object\", \"raw\": \"<raw-signature>\", \"signature\": { \"properties\": [{ \"key\": \"<property-name>\"|{ <property-key-type> }, \"value\": { <property-type>, \"required\": <true/false> } }, ...] } }```\nFunction Signature  | ```let x: (x: string) => void;``` | ```{ \"name\": \"signature\", \"type\": \"function\", \"raw\": \"<raw-signature>\", \"signature\": { \"arguments\": [{ \"name\": \"<argument-name>\", \"type\": { <argument-type> } }, ...], \"return\": { <return-type> } } }```\nCallable-Object/Function-Object Signature | ```let x: { (x: string): void, prop: string };``` | ```{ \"name\": \"signature\", \"type\": \"object\", \"raw\": \"<raw-signature>\", \"signature\": { \"properties\": [{ \"key\": \"<property-name>\"|{ <property-key-type> }, \"value\": { <property-type>, \"required\": <true/false> } }, ...], \"constructor\": { <function-signature> } } }```\nTuple | ```let x: [foo, \"value\", number];``` | ```{ \"name\": \"tuple\", \"raw\": \"<raw-signature>\", \"elements\": [{ <element-type> }, ...] }```\nUnion | ```let x: number | string;``` | ```{ \"name\": \"union\", \"raw\": \"<raw-signature>\", \"elements\": [{ <element-type> }, ...] }```\nIntersect | ```let x: number & string;``` | ```{ \"name\": \"intersect\", \"raw\": \"<raw-signature>\", \"elements\": [{ <element-type> }, ...] }```\nNullable modifier | ```let x: ?number;``` | ```{ \"name\": \"number\", \"nullable\": true }```\n\n## Result data structure\n\nThe structure of the JSON blob / JavaScript object is as follows:\n\n```\n{\n  [\"description\": string,]\n  [\"props\": {\n    \"<propName>\": {\n      \"type\": {\n        \"name\": \"<typeName>\",\n        [\"value\": <typeValue>]\n        [\"raw\": string]\n      },\n      \"flowType\": <flowType>,\n      \"required\": boolean,\n      \"description\": string,\n      [\"defaultValue\": {\n        \"value\": string,\n        \"computed\": boolean\n      }]\n    },\n    ...\n  },]\n  [\"composes\": <componentNames>]\n}\n```\n(`[...]` means the property may not exist if such information was not found in the component definition)\n\n- `<propName>`:  For each prop that was found, there will be an entry in `props` under the same name.\n- `<typeName>`: The name of the type, which is usually corresponds to the function name in `React.PropTypes`. However, for types define with `oneOf`, we use `\"enum\"`  and for `oneOfType` we use `\"union\"`. If a custom function is provided or the type cannot be resolved to anything of `React.PropTypes`, we use `\"custom\"`.\n- `<typeValue>`: Some types accept parameters which define the type in more detail (such as `arrayOf`, `instanceOf`, `oneOf`, etc). Those are stored in `<typeValue>`. The data type of `<typeValue>` depends on the type definition.\n- `<flowType>`: If using flow type this property contains the parsed flow type as can be seen in the table above.\n\n\n[react]: http://facebook.github.io/react/\n[flow]: http://flowtype.org/\n[recast]: https://github.com/benjamn/recast\n[babylon]: https://github.com/babel/babylon\n[classes]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/reactjs/react-docgen.git"
  },
  "scripts": {
    "build": "rimraf dist/ && babel src/ --out-dir dist/ --ignore __tests__,__mocks__",
    "lint": "eslint src/ bin/",
    "prepublish": "yarn build",
    "preversion": "yarn lint",
    "test": "jest",
    "test:ci": "yarn lint && yarn flow && yarn test --runInBand",
    "watch": "yarn build --watch"
  },
  "version": "3.0.0-beta12"
}
